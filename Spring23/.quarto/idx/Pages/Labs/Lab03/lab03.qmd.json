{"title":"Lab03","markdown":{"yaml":{"title":"Lab03","subtitle":"Comparisons, Conditionals, and Functions","author":[{"name":"PSTAT 5A, with Ethan Marzban","affiliations":[{"name":"Spring 2023"}]}],"author-title":"Course","affiliation-title":"Quarter","format":"html","title-block-banner":"#4144a6","css":"styles.css"},"headingText":"Comparisons","containsRefs":false,"markdown":"\n\n---\n\n\nHere's a question: is `2` less than `3`? Well, yes it is! If we wanted to confirm this, we could simply ask Python whether `2` is less than `3` by running\n```{python}\n#| echo: True\n\n2 < 3\n```\n\nNotice, however, *how* Python answered this question: it simply returned `True`. Let's see what the data type of `True` is:\n```{python}\n#| echo: True\n\ntype(True)\n```\n\n`True` is of the type `bool`, which is short for `boolean`. There are only two boolean quantities in Python: `True` and `False`. Let's see how we can generate a `False` value:\n```{python}\n#| echo: True\n\n3 < 2\n```\n\nHere is a list of comparison operators, taken from the [Inferential Thinking](https://inferentialthinking.com/chapters/04/3/Comparison.html) textbook:\n\n| **Comparison** | **Operator** | **True Example** | **False Example** |\n|:----:|:-----:|:----:|:----:|\n| Less than | `<` | `2 < 3` | `2 < 2`  |\n| Greater than | `>` | `3 < 2` | `3 > 3`  |\n| Less than or equal | `<=` | `2 <= 2` | `3 <= 2`  |\n| Greater than or equal | `>=` | `3 >= 3` | `2 >= 3`  |\n| Equal | `==` | `3 == 3` | `3 == 2`  |\n| Not equal | `!=` | `3 != 2` | `2 != 2`  |\n\nOne nice thing about Python is that it allows for multiple simultaneous comparisons. For example,\n```{python}\n2 < 3 < 4\n```\n\n:::{.callout-note}\n### Important\nIn a multiple comparison, Python will only return `True` when *all* of the included comparisons are true.\n:::\n\nFor instance, `2 < 3 < 1` would return `False`, because even though `2` is less than `3` it is not true that `3` is less than `1`. \\\n\nBelieve it or not, you can compare strings as well! Python compares strings *alphabetically*; that is, letters at the beginning of the alphabet are considered to have smaller ordinal value than letters at the end of the alphabet. For example:\n\n```{python}\n\"apple\" < \"banana\"\n```\n```{python}\n\"zebra\" < \"zanzibar\"\n```\n```{python}\n\"cat\" <= \"catenary\"\n```\n\n::: {.callout-important}\n## Task 1\nCheck how `\"statistics\"` and `\"Statistics\"` (note the capitalization!) compare. Use this to answer the question: when Python is comparing strings, does it give precedence to capital letters or not?\n:::\n\nFinally, we discuss how comparisons work in the context of lists and arrays. The way Python compares lists is by what is known as **lexicographical order**. From the official Python [help documentation](https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types), this means\n\n>first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted.\n\nFor instance, `[1, 2, 3] < [2, 1, 1]` would return `True` since `1` (the first element of the first list) *is* less than `2` (the first element of the second list). \\\n\nThe comparison of arrays is a little more straightforward, except\n\n:::{.callout-note}\n### Important\nWhen comparing two arrays, the arrays must be of the same length.\n:::\n\nTo see exactly how comparison of arrays works, let's work through a Task:\n\n::: {.callout-important}\n## Task 2\nMake an array with the elements `1`, `2`, and `3`, and call this `x`. Make another array with the elements `2`, `3`, `1`, and call this `y`. Run `x < y`, and comment on the result.\n:::\n\nWhat the previous task illustrates is that Python compares arrays element-wise. \n\n## Conditionals\n\nNow, we can use comparisons for much more than verifying simple arithmetic relationships. One of the main areas in which comparisons arise is the area of **conditional expressions**. \\\n\nSimply put, conditional expressions are how we can convey a set of choices to Python. As an example, let's consider finding someone's city based on their zip code. To simplify, let's assume the only zip codes we consider are `9311`, `93120`, and `93150`. From postal data, we know that:\n\n- a zip code of `93117` corresponds to Goleta\n- a zip code of `93120` corresponds to Santa Barbara\n- a zip code of `93150` corresponds to Montecito\n\nWe can rephrase this information in terms of \"if\" statements:\n\n- If a person has a zip code of `93117`, then they are in Goleta\n- Otherwise, if they have a zip code of `93120`, then they are in Santa Barbara\n- Otherwise, if they have a zip code of `93150`, then they are in Montecito\n\nThis is precisely the syntax we would use when translating this experiment into Python syntax:\n```{python}\n#| echo: True\n#| eval: False\n\nif zip_code == 93117:\n  location = \"Goleta\"\nelif zip_code == 93120:\n  location = \"Santa Barbara\"\nelif zip_code == 93150:\n  location = \"Montecito\"\n```\n\nBy the way: `elif` is an abbreviation for `else if`, which itself can be thought of as equivalent to `otherwise, if`. \\\n\nHere's the general syntax of a conditional expression in Python:\n\n```{python}\n#| echo: True\n#| eval: False\n\nif <condition 1>:\n  <task 1>\nelif <condition 2>:\n  <task 2>\n...\nelse:\n  <final task>\n```\n\nWhen executing the above conditional statement, Python first checks whether `<condition 1>` returns a value of `True` or `False`. If it returns a value of `True`, then `<task 1>` is executed and the statement ends. Otherwise, Python checks whether `<task 2>` is `True` or `False`; if it is `True` then `<condition 2>` is executed, etc. \\\n\n:::{.callout-note}\n### Important\nIn the example code above: if `<condition 1>` is `True`, then no tasks beyond `<task 1>` are evaluated. If `<condition 2>` is `True`, then no tasks beyond `<task 2>` are evaluated. And so on and so forth.\n:::\n\n\n::: {.callout-important}\n## Task 3\nConsider the code:\n```{python}\n#| eval: False\n\nx = 2\n\nif x < 2:\n    x = \"hello\"\nelif x < 3:\n    x = \"goodbye\"\nelse:\n    x = \"take care\"\n```\n**Before running any code**, write down what you think the result of executing `x` would be. Then, run the loop, execute `x`, and check whether your answer was correct or not.\n:::\n\n::: {.callout-caution}\n## Caution\nIndentation is **very** important in Python.\n:::\n\nFor example, if instead of the conditional expression in Task 3 we had instead put\n```{python}\n#| eval: False\n\nx = 2\n\nif x < 2:\nx = \"hello\"\nelif x < 3:\nx = \"goodbye\"\nelse:\nx = \"take care\"\n```\nthen we would have received an error!\n\n\n## Functions\n\nFinally, let's quickly discuss Python functions. We've already been using quite a few functions:\n\n\n::: {.callout-important}\n## Task 4\nIn a Markdown cell, write down three functions we've used in the previous labs.\n:::\n\nIf you recall, the general syntax for calling a function is:\n```{python}\n#| eval: False\n\n<function name>(<arg1>, <arg2>, ... )\n```\nwhere `<function name>` denotes the function name and `<arg1>`, `<arg2>`, etc. denote the arguments of the function. \\\n\nCreating your own function in Python is actually fairly simple! Here is the syntax we use:\n```{python}\n#| eval: False\n\ndef <function name>(<list out the argument names>):\n  \"\"\"include a 'docstring' here\"\"\"\n  <body of the function>\n  return <what you want the function to output>\n```\n\nFor example,\n```{python}\ndef f(x, y):\n  \"\"\"returns x^2 + y^2\"\"\"\n  return x**2 + y**2\n```\ncreates a function `f` that can be called on two arguments, `x` and `y`, and returns the sum of squares of the arguments; e.g.\n```{python}\nf(3, 4)  # should return 3^2 + 4^2 = 25\n```\n\nBy the way, the **docstring** referenced above is a verbal description of what the function does. (Recall from Lab01 that it is just a multi-line comment, since it is enclosed in triple quotation marks!). All functions should include a docstring to convey to the user what the function does.\n\n:::{.callout-note}\n### Important\nIf you don't include a `return` statement in the definition of a function, then your function will never return anything.\n:::\n\nFor instance,\n```{python}\ndef g(x, y):\n  \"\"\"should return x^2 + y^2\"\"\"\n  x**2 + y**2\n\ng(3, 4)\n```\n\n::: {.callout-important}\n## Task 5\nWrite a function called `cent_to_far()` which takes in a single temperature `c` as measured in degrees Centigrade and returns the corresponding temperature in degrees Farenheit. Check that `cent_to_far(0)` correctly returns `0` and `cent_to_far(68)` correctly returns `69.7777`. As a reminder:\n$$ {}^{\\circ}\\mathrm{F} = \\frac{5}{9} ({}^{\\circ}\\mathrm{C}) + 32 $$\n:::\n\nFinally, let's combine some things by way of a concluding Task:\n\n::: {.callout-important}\n## Task 6\nWrite a function called `parity()` that returns the parity (i.e. whether a number is even or odd) of an input `x`. Call your `parity()` function on `2` and then `3` to make sure your function behaves as expected. **Some hints:**\n\n- Recall that `%` is the *modulus* operator in Python. Specifically, `x % y` returns the remainder of performing `y` divided by `x`.\n- Recall that even numbers are divisible by `2` (so what does this mean about the remainder of dividing `x` by `2` if `x` is even?)\n:::\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css","styles.css"],"toc":true,"output-file":"lab03.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","theme":"sandstone","title":"Lab03","subtitle":"Comparisons, Conditionals, and Functions","author":[{"name":"PSTAT 5A, with Ethan Marzban","affiliations":[{"name":"Spring 2023"}]}],"author-title":"Course","affiliation-title":"Quarter","title-block-banner":"#4144a6"},"extensions":{"book":{"multiFile":true}}}}}