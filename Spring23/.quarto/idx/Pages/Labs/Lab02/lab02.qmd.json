{"title":"Lab02","markdown":{"yaml":{"title":"Lab02","subtitle":"Data Classes","author":[{"name":"PSTAT 5A, with Ethan Marzban","affiliations":[{"name":"Spring 2023"}]}],"author-title":"Course","affiliation-title":"Quarter","format":"html","title-block-banner":"#4144a6","css":"styles.css"},"headingText":"Data Classes","containsRefs":false,"markdown":"\n\n---\n\n\nLast week, we were introduced to the notion of data types. Recall that \"data type\" can be thought of as the *category* (or *type*) of data- i.e. integer, float, character, etc. \\\n\nIn Python, however, we often need to aggregate data into larger structures, often referred to as **data classes**.\n\n### Lists\n\nPerhaps the most fundamental data structure in Python is that of a **list.** Just like lists in real life or in mathematics, Python lists are just collections of items enclosed in square brackets:\n```{python}\n#| eval: false\n[<item 1>, <item 2>, ..., <item n>]\n```\nAgain, the items in a list can be of any data type; we can even mix and match data types!\n\n:::{.callout-important}\n## Task 1\n\nCreate a list containing the elements `1`, `\"hi\"`, `3.4`, and `\"PSTAT 5A\"`. Assign this list to a variable called `list1`.\n:::\n\nJust as we were able to use a Python function (`type()`) to check the *type* of a particular piece of data, we can also use Python to check the *structure* or *class* of a piece of data. It turns out that we use the same function as before- namely, `type()`!\n\n:::{.callout-important}\n## Task 2\n\nRun the code `type(list1)`.\n:::\n\n## Indexing\n\nAlright, now that we can store data in lists, how can we *access* elements in a list? The answer is to use what is known as **indexing.** \\\n\nGiven a list `x`, we access the `i`^th^ element using the code\n```{python}\n#| eval: false\nx[i]\n```\nThe reason we call this \"indexing\" is because the number that goes between the brackets is the *index* of the element that we want.\n\n:::{.callout-warning}\n## Caution\nPython begins indexing at 0.\n:::\n\nWhat does this mean? Well, let's see by way of an example.\n\n:::{.callout-important}\n## Task 3\n\na. Create a list with the numbers `1` through `10`, inclusive.\n\nb. Run the code `x[1]`.\n\nc. Run the code `x[0]`.\n:::\n\nSo, what we would colloquially call the *first* element of a list, Python calls the *zeroeth* element. \n\n\\\n\nAlright, let's put together some of the concepts we just learned.\n\n:::{.callout-important}\n## Task 4\n\nCreate a list called `x` that contains the elements `1`, `\"two\"`, `3.5`, `\"four\"`, and `\"five five\"`.  **Answer the following questions WITHOUT running any code, writing your answers as a comment in a code cell:**\n\na. What would be the output of `type(x)`?\nb. What would be the output of `type(x[1])`?\nc. What would be the output of `x[0]`?\n\n\n**Now**, run code to verify your answers to the above three questions.\n:::\n\n## Tables\n\n```{python}\n#| echo: false\n\nfrom datascience import *\n```\n\nAnother very useful data structure in Python is that of a **table**. Python tables behave pretty much the same as the tables we've used in, say, math- they are a grid of values arranged sequentially. \\\n\nTables can be created using the `Table()` function in Python, which itself comes from the `datascience` module. The general syntax of creating a table with the `Table()` function is:\n```{python}\n#| eval: false\n\nTable().with_columns(\n  \"<col 1 name>\", [<col 1, val 1>, <col 1, val 2>, ... ],\n  \"<col 2 name>\", [<col 2, val 1>, <col 2, val 2>, ... ],\n  ...\n)\n```\n\nFor example,\n```{python}\nTable().with_columns(\n  \"Name\", [\"Ethan\", \"Morgan\", \"Amy\"],\n  \"ID\", [12345, 10394, 20343],\n  \"Office\", [\"South Hall\", \"South Hall\", \"North Hall\"]\n)\n```\n\nThere is nothing stopping us from assigning a table to a variable! For example, after running\n```{python}\ntable1 = Table().with_columns(\n  \"Name\", [\"Ethan\", \"Morgan\", \"Amy\"],\n  \"ID\", [12345, 10394, 20343],\n  \"Fav_Drink\", [\"Iced Tea\", \"Coffee\", \"Sprite\"]\n)\n```\nthe variable `table1` is equivalent to the table displayed above:\n```{python}\ntable1\n```\n\n:::{.callout-tip}\n## Terminology\nSometimes in Python we will encounter expressions of the form\n```{python}\n#| eval: false\n<object type>.<function name>()\n```\nIn this syntax, the function `<function name>` is said to be a **method**. For example, the function `with_columns()` is a method for the `Table` object.\n:::\n\nThe `datascience` module contains a plethora of methods we can use to manage tables. For example, the `select()` method can be used to select columns by name:\n```{python}\ntable1.select(\"ID\")\n```\n:::{.callout-tip}\n## Syntax\nMethods are always appended to either a function that creates a blank object type (like `Table()`) or a variable of the correct type.\n:::\n\n\n:::{.callout-important}\n## Task 5\nRead the list of methods for Table objects at [http://data8.org/datascience/tables.html](http://data8.org/datascience/tables.html), and write down (in a code cell, using comments) **at least three** different methods, including a short description of what each method does. For example:\n```{python}\n#| eval: false\n# .with_columns(): adds specified columns to a table.\n```\n:::\n\n\n:::{.callout-important}\n## Task 6\na. Create the following table, and assign it to a variable called `profs`:\n```{python}\n#| echo: false\nTable().with_columns(\n  \"Professor\", [\"Dr. Swenson\", \"Dr. Wainwright\", \"Dr. Mouti\"],\n  \"Office\", [\"South Hall\", \"Old Gym\", \"Old Gym\"],\n  \"Course\", [\"PSTAT 130\", \"PSTAT 120A\", \"PSTAT 126\"]\n)\n```\n\nRun a cell containing only the code `profs` to make sure (visually) that your table looks correct.\n\nb. Select the column called `Course` from `profs`.\n\nc. **Append** (i.e. add) a new row to the `profs` table, containing the following information:\n```{python}\n#| echo: false\nTable().with_columns(\n  \"Professor\", [\"Dr. Ravat\"],\n  \"Office\", [\"South Hall\"],\n  \"Course\", [\"PSTAT 120B\"]\n)\n```\nRun a cell containing only the code `profs` to make sure (visually) that the appending was successful.\n\n:::\n\nSuppose we want to select rows of a table that satisfy a given condition. For example, if we wanted to find the information of only people who like Sprite in the `table1` table above, we would call\n```{python}\ntable1.where(\"Fav_Drink\", \"Sprite\")\n```\nWhat would happen if we tried to select the rows of `table1` with `Coke` in the `Fav_Drink` column? Well, since there is nobody in `table1` that has coke as their favorite drink, we should hope that Python returns an empty table.\n```{python}\ntable1.where(\"Fav_Drink\", \"Coke\")\n```\nSure enough, Python has returned an empty table!\n\n## Arrays\n\nThe final Data Structure we will examine in this class is that of an **array**. Arrays behave very similarly to Tables, with a few differences. For one, the syntax used to create an array is slightly different:\n```{python}\n#| eval: false\nmake_array(<item 1>, <item 2>, <item 3>, ...)\n```\nFor example,\n```{python}\nmake_array(\"Spring\", \"Summer\", \"Autumn\", \"Winter\")\n```\nYou may ask- what's that `dtype='<U6'` symbol at the end of the output? For now, don't worry about it, as we will revisit this later. \n\n## Lists vs. Arrays\n\nSo, we now know about three different data classes in Python: lists, tables, and arrays. At first glance, lists and arrays may seem somewhat similar. However, there are a few key differences between them:\n\n:::{.callout-important}\n## Task 7\n\nMake a list called `my_list` containing the elements `1`, `2`, and `3`, and make an array called `my_array` also containing the elements `1`, `2`, and `3`. Run the following commands in separate code cells:\n\n- `sum(my_list)`\n- `sum(my_array)`\n- `my_list + 2`\n- `my_array + 2`\n:::\n\nWhat the previous Task illustrates is the fact that arrays lend themselves to **element-wise operations**, whereas lists do not. One important limitation about arrays, though, is that the elements in an array must all be of the same data type. If you try to make an array consisting of elements that are different data types Python will still run, however it will not run in the way you expect it to!"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css","styles.css"],"toc":true,"output-file":"lab02.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","theme":"sandstone","title":"Lab02","subtitle":"Data Classes","author":[{"name":"PSTAT 5A, with Ethan Marzban","affiliations":[{"name":"Spring 2023"}]}],"author-title":"Course","affiliation-title":"Quarter","title-block-banner":"#4144a6"},"extensions":{"book":{"multiFile":true}}}}}