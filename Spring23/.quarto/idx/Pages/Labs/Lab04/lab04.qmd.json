{"title":"Lab04","markdown":{"yaml":{"title":"Lab04","subtitle":"Descriptive Statistics","author":[{"name":"PSTAT 5A, with Ethan Marzban","affiliations":[{"name":"Spring 2023"}]}],"author-title":"Course","affiliation-title":"Quarter","format":"html","title-block-banner":"#4144a6","css":"styles.css"},"headingText":"Modules, Revisited","containsRefs":false,"markdown":"\n\n---\n\nIt's finally time for us to revisit our notions of **descriptive statistics** (from Week 1 of the course), now in the context of Python!\n\n\nBefore we talk about plotting, we will need to quickly talk about **modules** again. Recall from Lab01 that modules are Python files containing definitions for functions and classes. Up until now, we've been importing all functions and classes from a module using the command\n```{python}\n#| eval: False\n\nfrom <module name> import *\n```\n\nThere is another way to import modules, which is the following:\n```{python}\n#| eval: False\n\nimport <module name> as <abbreviation>\n```\n\nFor example,\n```{python}\n#| eval: False\n\nimport numpy np\n```\nnot only imports the `numpy` module but imports it with the abbreviation (i.e. nickname) `np` so that we can simply write `np` in place of `numpy`. \\\n\nThe reason this is particularly useful is because module names can sometimes be quite long, so being able to refer to the module with a shortened nickname will save a lot of time! \\\n\nIn general, if we import a module using\n```{python}\n#| eval: False\n\nimport <module name> as <abbreviation>\n```\nwe reference functions from `<module name>` using the syntax\n```{python}\n#| eval: False\n<abbreviation>.<function name>()\n```\nFor example, after having imported the `numpy` module with the nickname `np`, we access the `sin()` function contained in the `numpy` module by calling\n```{python}\n#| eval: False\n\nnp.sin()\n```\n\n:::{.callout-important}\n## Task 1\n\na. Import the `numpy` module as `np`, and check that `np.sin(0)` returns a value of `0`.\n\nb. Import the `datascience` module as `ds`, and check that \n```{python}\n#| eval: False\nds.Table().with_columns(\n  \"Col1\", [1, 2, 3],\n  \"Col2\", [2, 3, 4]\n)\n```\ncorrectly displays as\n```{python}\n#| echo: False\nimport datascience as ds\nds.Table().with_columns(\n  \"Col1\", [1, 2, 3],\n  \"Col2\", [2, 3, 4]\n)\n```\n:::\n\n:::{.callout-warning}\n## Important\nIf you import a module with an abbreviation `<abbreviation>`, you must always use the abbreviation when referencing the module; not the original module name.\n:::\n\nFor example, after importing `numpy` as `np`, running `numpy.sin()` would return an error.\n\n## Numerical Summaries\n\n### Measures of Central Tendency\n\nRecall that for a list of numbers $X = \\{x_i\\}_{i=1}^{n}$, the mean is defined to be\n$$ \\overline{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i = \\frac{1}{n} (x_1 + \\cdots + x_n) $$\nComputing the mean of a list or array of numbers in Python is relatively simple, using the `np.mean()` function [recall that we imported the `numpy` module with the abbreviation `np`, meaning `np.mean()` is a shorthand for `numpy.mean()`]. Similarly, to compute the median of a list or array we can use `np.median()`.\n\n:::{.callout-important}\n## Task 2\n\nLet `x_list` be a list containing the elements `1`, `2`, and `3`, and let `x_array` be an array containing the elements `1`, `2`, and `3`. Compute the mean and median of `x_list` and `x_array` using the appropriate functions from the `numpy` module.\n:::\n\n### Measures of Spread\n\nRecall that we also discussed several measures of spread:\n\n- Standard deviation\n- IQR (Interquartile Range)\n- Range\n\nSure enough, the `numpy` module contains several functions which help us compute these measures. Let's examine each separately.\n\n::: {.callout-important}\n## Task 3\n- Look up the help file on the function `np.ptp()`, and describe what it does. Also, answer the question: what does `ptp` actually stand for?\n- Now, apply the `np.ptp()` function on your `x_list` and `x_array` variables from Task 1 above and check that it functions like you expect.\n:::\n\nNext, we tackle a slightly peculiar function: `np.std()`. We expect this to compute the standard deviation of a list/array, but...\n\n::: {.callout-important}\n## Task 4\na) Compute the standard deviation of the `x_list` variable from Task 1 **by hand**, and write down the answer using a comment or Markdown cell.\nb) Now, run `np.std(x_list)`. Does this answer agree with what you found in part (a) above?\nc) Now, recompute the standard deviation of `x_list` by hand but this time use $(1/n)$ instead of $(1 / n - 1)$ in the formula. How does *this* answer compare with the result of `np.std(x_list)`?\n:::\n\nThe result of the previous Task is the following: given a list `x = [x1, x2, ..., xn]`, running `np.std(x)` actually computes\n$$ \\sqrt{ \\frac{1}{n} \\sum_{i=1}^{n} (x_i - \\overline{x})^2 } $$\nas opposed to our usual definition of standard deviation\n$$ s_X = \\sqrt{ \\frac{1}{n - 1} \\sum_{i=1}^{n} (x_i - \\overline{x})^2} $$\nWe can actually fix this issue by passing in an additional argument to the `np.std()` function:\n\n::: {.callout-important}\n## Task 4 (cont'd)\nd) Run `np.std(x_list, ddof = 1)` and check whether this matches the result of part (a) above.\n:::\n\n:::{.callout-tip}\n## Result\nTo compute the standard deviation of a list `x`, we run `np.std(x, ddof = 1)`.\n:::\n\nFinally, we turn to the IQR: to compute the IQR of a list/array `x`, we use (after importing `numpy` as `np`)\n```{python}\n#| eval: False\n\nnp.diff(np.percentile(x, [25,75]))[0]\n```\n\n## Visualizations\n\nIt's finally time to make pretty pictures! The module we will use to generate visualizations in this class is the `matplotlib` module (though there are quite a few other modules that work for visualizations as well). The official website for `matplotlib` can be found at [https://matplotlib.org/](https://matplotlib.org/). \\\n\nBefore we generate any plots, we will need to run the following code once:\n```{python}\n#| eval: False\n%matplotlib inline\nimport matplotlib\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\n```\n\nHere's what these lines of code are doing:\n\n- `%matplotlib inline` tells Jupyter to actually display our plots in our notebook (if we didn't include this line, our plots wouldn't display)\n- `import matplotlib` imports the `matplotlib` module\n- `import matplotlib.pyplot as plt` imports the `pyplot` submodule (a submodule is just a module contained within another larger module) with the abbreviation `plt`.\n- `plt.style.use('seaborn-v0_8-whitegrid')` tells Jupyter to use a specific theme (called `seaborn-v0_8-whitegrid`) when generating plots.\n\nAgain, notice the beauty of the `import <module> as <abbreviation>` syntax- after running the third line above, we no longer need to write `matplotlib.pyplot`, just `plt`! Also, there are lots of other themes you can use when generating your plots: after completing this lab, I encourage you to consult [this](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html) reference guide for a list of a few other `pyplot` themes.\n\n### Boxplots and Histograms\n\nNow, let's proceed on to make some plots. The first two types of plots we will look at are the two we used to describe numerical data: namely, **boxplots** and **histograms**. The functions we will use are the `plt.boxplot()` and `plt.his()` functions, respectively.\n\n::: {.callout-important}\n## Task 5\na) Make a list called `y` that contains the following elements: `[1, 2, 3, 4, 5, 4, 3, 5, 4, 1, 2]`.\n\nb) Run `plt.boxplot(y);` (be sure to include the semicolon!). With any luck, your plot should look like:\n\n```{python}\n#| echo: False\n#| eval: True\n\n%matplotlib inline\nimport matplotlib\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nplt.figure(figsize=(4.5, 2.25))\n\ny = [1, 2, 3, 4, 5, 4, 3, 5, 4, 1, 2]\nplt.boxplot(y);\n```\n\nc. Let's make our boxplot horizontal, as opposed to vertical. Consult the help file on the `matplotlib.pyplot.boxplot()` function [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.boxplot.html) and figure out how to position your boxplot horizontally. Your new plot should look like:\n```{python}\n#| echo: False\n#| eval: True\nplt.figure(figsize=(4.5, 2.25))\nplt.boxplot(y, vert = False);\n```\n\nd. Next, let's add some color to our plot. Within your call to `plt.boxplot()`, add the following:\n`patch_artist=True, boxprops = dict(facecolor = \"aquamarine\")`\n(don't worry too much about what exactly this code is doing). Your boxplot should now look like this:\n```{python}\n#| echo: False\n#| eval: True\nplt.figure(figsize=(4.5, 2.25))\nplt.boxplot(y, vert = False, patch_artist = True, boxprops = dict(facecolor = \"aquamarine\"));\n```\n\ne. Finally, let's add a Title! Right below your call to `plt.boxplot()`, add the following:\n`plt.title(\"My First Python Boxplot\");` (again, note the semicolons).\nYour final plot should look like this:\n```{python}\n#| echo: False\n#| eval: True\nplt.figure(figsize=(4.5, 2.25))\nplt.boxplot(y, vert = False, patch_artist = True, boxprops = dict(facecolor = \"aquamarine\"));\nplt.title(\"My First Python Boxplot\");\n```\n\nf. Time for a review: based on the boxplot we just generated, what is the IQR of `y`? Write your answer in a Markdown cell. Then, use the syntax discussed in the previous section of this Lab to use Python to compute the IQR of `y`, and comment on the result.\n:::\n\nOf course, boxplots are not the only way to summarize numerical variables: we also have histograms!\n\n::: {.callout-important}\n## Task 6\nCall the `plt.hist()` function on the `y` list defined in Task 3, and use the [help file](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html) to add arguments to your call to `plt.hist()` function to generate the following plot:\n```{python}\n#| echo: False\n#| eval: True\nplt.figure(figsize=(4.5, 2.25))\nplt.hist(y, bins = 3, edgecolor = \"white\");\nplt.title(\"My First Python Histogram\");\n```\nPay attention to the number of bins!\n:::\n\n\n### Scatterplots\n\nWe should also quickly discuss how to generate scatterplots in Python.\n\n:::{.callout-important}\n## Task 7\n\na. Copy-paste the following code into a code cell, and then run that cell (don't worry about what this code is doing- we'll discuss that in a future lab).\n```{python}\n#| eval: False\nnp.random.seed(5)\n\nx1 = np.random.normal(0, 1, 100)\nx2 = x1 + np.random.normal(0, 1, 100)\n\nplt.scatter(x1, x2);\n```\nYour plot should look like this:\n```{python}\n#| echo: False\nimport numpy as np\nnp.random.seed(5)\n\nx1 = np.random.normal(0, 1, 100)\nx2 = x1 + np.random.normal(0, 1, 100)\n\nplt.figure(figsize=(4.5, 2.25))\nplt.scatter(x1, x2);\n```\n\nb. Add an x-axis label that says `\"x1\"` and a y-axis label that says `\"x2\"`. Your final plot should look like:\n```{python}\n#| echo: False\nplt.figure(figsize=(4.5, 2.25))\nplt.scatter(x1, x2);\nplt.xlabel(\"x1\");\nplt.ylabel(\"x2\");\nplt.title(\"My First Python Scatterplot\");\n```\n\nc. Does there appear to be an association between the variables `x1` and `x2`? If so, is the association positive or negative? Linear or nonlinear? Answer using a comment or a Markdown Cell.\n:::\n\n## Plotting a Function\n\nFinally, I'd like to take a quick detour from descriptive statistics and talk about how to plot a function using Python. As a concrete example, let's try and plot a sine curve from $0$ to $2\\pi$. \n\nIf you recall, on Lab01 we used the `sin()` function from the `math` module- it turns out that the `numpy` module (which, recall, we have imported as `np`) also has a `sin()` function, so let's use that one today:\n```{python}\n#| eval: False\n\nnp.sin()\n```\n\nNext, we create a set of finely-spaced points between our two desired endpoints (in this case, $0$ and $2\\pi$, respectively). We will do so using the `np.linspace()` function, which works as follows:\n```{python}\n#| eval: False\n\nnp.linspace(start, stop, num)\n```\ncreates a set of `num` evenly-spaced values between `start` and `stop`, respectively. For instance:\n```{python}\nnp.linspace(0, 1, 10)\n```\nIn the context of plotting, the more points we generate the smoother our plot will seem (you will see what this means in a minute). As such, let's start with `150` points between `0` and `2 * pi`:\n```{python}\nx = np.linspace(0, 2 * np.pi, 150)\n```\nFinally, we call the `plt.plot()` function on `x` and `np.sin(x)` to generate our plot:\n```{python}\nplt.figure(figsize=(4.5, 2.25))\nplt.plot(x, np.sin(x))\n```\n\nLet's see what would have happened if we used fewer values in our `np.linspace()` call:\n```{python}\n#| eval: False\nxnew = np.linspace(0, 2 * np.pi, 10)\nplt.plot(xnew, np.sin(xnew))\n```\n```{python}\n#| echo: False\nxnew = np.linspace(0, 2 * np.pi, 10)\nplt.figure(figsize=(4.5, 2.25))\nplt.plot(xnew, np.sin(xnew))\n```\nSo, the more points we include in our call to `np.linspace()`, the smoother our final function will look! \\\n\nSo, to summarize, here is the general \"recipe\" to plot a function `f()` between two values `a` and `b` in Python:\n\n1. Let `x = np.linspace(a, b, <some large value>)`\n2. Call `plt.plot(x, f(x))`\n3. Add labels/titles as necessary\n\n:::{.callout-important}\n## Task 8\nGenerate a plot of the function $f(x) = x - x^2 \\sin(x)$ between $x = -10$ and $x = 10$. Experiment around with the number of values generated by `np.linspace()` to ensure your plot is relatively smooth. Be sure to include axis labels; also, change the color of the graph to red. Your final plot should look something like this:\n```{python}\n#| echo: False\ndef f(x):\n    return x - (x ** 2) * np.sin(x)\n  \nx = np.linspace(-10, 10, 150)\nplt.figure(figsize=(4.5, 2.25))\nplt.plot(x, f(x), color='red');\nplt.xlabel(\"x\");\nplt.ylabel(\"f(x)\");\nplt.title(\"Plot of f(x) = x - x^2 sin(x)\");\n```\n:::\n\n## Note on Submission\n\nPlease note- from here on out, we will expect you to modify your notebook metadata to include your name and NetID (**not your Perm Number!**). For a refresher on how to do that, please consult Lab01."},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css","styles.css"],"toc":true,"output-file":"lab04.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","theme":"sandstone","title":"Lab04","subtitle":"Descriptive Statistics","author":[{"name":"PSTAT 5A, with Ethan Marzban","affiliations":[{"name":"Spring 2023"}]}],"author-title":"Course","affiliation-title":"Quarter","title-block-banner":"#4144a6"},"extensions":{"book":{"multiFile":true}}}}}